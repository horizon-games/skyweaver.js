/* eslint-disable */
// api v0.3.0 e047af6bf84f8be5d8448151fa67f81df766c420
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.3.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "e047af6bf84f8be5d8448151fa67f81df766c420"


//
// Types
//
export enum AccountStatus {
  ACTIVE = 'ACTIVE',
  SUSPENDED = 'SUSPENDED',
  BANNED = 'BANNED',
  VIP = 'VIP',
  FLAGGED = 'FLAGGED',
  TO_DELETE = 'TO_DELETE',
  DELETED = 'DELETED'
}

export enum PlayerRank {
  UNKNOWN = 'UNKNOWN',
  WANDERER = 'WANDERER',
  RECRUIT = 'RECRUIT',
  APPRENTICE = 'APPRENTICE',
  SCHOLAR = 'SCHOLAR',
  PROPHET = 'PROPHET',
  MASTER = 'MASTER',
  GRANDMASTER = 'GRANDMASTER'
}

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  SKYWEAVER_ASSETS = 'SKYWEAVER_ASSETS'
}

export enum ItemType {
  UNKNOWN = 'UNKNOWN',
  USDC = 'USDC',
  SW_BASE_CARDS = 'SW_BASE_CARDS',
  SW_SILVER_DUST = 'SW_SILVER_DUST',
  SW_SILVER_CARDS = 'SW_SILVER_CARDS',
  SW_GOLD_CARDS = 'SW_GOLD_CARDS',
  SW_CONQUEST_TICKET = 'SW_CONQUEST_TICKET',
  SW_CRYSTALS = 'SW_CRYSTALS',
  SW_STICKERS = 'SW_STICKERS',
  SW_HERO = 'SW_HERO'
}

export enum FeedEventType {
  LEVELUP = 'LEVELUP',
  MATCH = 'MATCH',
  REWARD = 'REWARD',
  TRADE = 'TRADE',
  RANKUP = 'RANKUP',
  LEADERBOARD_REWARD = 'LEADERBOARD_REWARD',
  HERO_UNLOCK = 'HERO_UNLOCK',
  IAP_CONQUEST_MINTING = 'IAP_CONQUEST_MINTING',
  DELAYED_REWARD = 'DELAYED_REWARD',
  DELAYED_REWARD_MINTED = 'DELAYED_REWARD_MINTED',
  STARTED_DECK_UNLOCK = 'STARTED_DECK_UNLOCK'
}

export enum Hero {
  UNKNOWN = 'UNKNOWN',
  ADA = 'ADA',
  SAMYA = 'SAMYA',
  FOX = 'FOX',
  LOTUS = 'LOTUS',
  TITUS = 'TITUS',
  IRIS = 'IRIS',
  BOURAN = 'BOURAN',
  HORIK = 'HORIK',
  ZOEY = 'ZOEY',
  AXEL = 'AXEL',
  ARI = 'ARI',
  MIRA = 'MIRA',
  MAI = 'MAI',
  BANJO = 'BANJO',
  SITTI = 'SITTI'
}

export enum DeckClass {
  UNKNOWN_CLASS = 'UNKNOWN_CLASS',
  STR = 'STR',
  HRT = 'HRT',
  AGY = 'AGY',
  INT = 'INT',
  WIS = 'WIS',
  STH = 'STH',
  STA = 'STA',
  STI = 'STI',
  STW = 'STW',
  HRA = 'HRA',
  HRI = 'HRI',
  HRW = 'HRW',
  AGI = 'AGI',
  AGW = 'AGW',
  INW = 'INW'
}

export enum CardType {
  UNIT = 'UNIT',
  SPELL = 'SPELL'
}

export enum CardKeyword {
  ARMOR = 'ARMOR',
  STEALTH = 'STEALTH',
  GUARD = 'GUARD',
  BANNER = 'BANNER',
  WITHER = 'WITHER',
  DEATH = 'DEATH'
}

export enum CardElement {
  WATER = 'WATER',
  FIRE = 'FIRE',
  EARTH = 'EARTH',
  AIR = 'AIR',
  MIND = 'MIND',
  METAL = 'METAL',
  LIGHT = 'LIGHT',
  DARK = 'DARK'
}

export enum CardStatus {
  PLAY = 'PLAY',
  BLOCKED = 'BLOCKED',
  CODE = 'CODE'
}

export enum CardClass {
  STR = 'STR',
  HRT = 'HRT',
  AGY = 'AGY',
  INT = 'INT',
  WIS = 'WIS',
  TOK = 'TOK'
}

export enum GameMode {
  UNKNOWN = 'UNKNOWN',
  RANKED_CONSTRUCTED = 'RANKED_CONSTRUCTED',
  CHALLENGE_CONSTRUCTED = 'CHALLENGE_CONSTRUCTED',
  TUTORIAL = 'TUTORIAL',
  PRACTICE = 'PRACTICE',
  RANKED_DISCOVERY = 'RANKED_DISCOVERY',
  CONQUEST_CONSTRUCTED = 'CONQUEST_CONSTRUCTED',
  CONQUEST_DISCOVERY = 'CONQUEST_DISCOVERY',
  WARM_UP = 'WARM_UP',
  CHALLENGE_DISCOVERY = 'CHALLENGE_DISCOVERY'
}

export enum MatchStatus {
  UNKNOWN = 'UNKNOWN',
  COMPLETED = 'COMPLETED',
  ABANDONED = 'ABANDONED',
  FORFEITED = 'FORFEITED',
  IN_PROGRESS = 'IN_PROGRESS',
  CRASHED = 'CRASHED'
}

export enum RewardType {
  EXP = 'EXP',
  CARD = 'CARD',
  RANK = 'RANK',
  PRISM = 'PRISM',
  HERO = 'HERO',
  HERO_SKIN = 'HERO_SKIN',
  DECK = 'DECK'
}

export enum DeckType {
  RANDOM = 'RANDOM',
  CUSTOM = 'CUSTOM',
  LOCKED_STARTER = 'LOCKED_STARTER',
  UNLOCKED_STARTER = 'UNLOCKED_STARTER'
}

export enum ConquestStatus {
  UNKNOWN = 'UNKNOWN',
  IN_PROGRESS = 'IN_PROGRESS',
  REWARDS_PENDING = 'REWARDS_PENDING',
  COMPLETED = 'COMPLETED'
}

export enum ConquestMatchResult {
  UNKNOWN = 'UNKNOWN',
  WIN = 'WIN',
  LOSS = 'LOSS',
  DRAW = 'DRAW'
}

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export enum BannerType {
  INFO = 'INFO',
  WARNING = 'WARNING',
  EMERGENCY = 'EMERGENCY'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface Account {
  address: string
  name: string
  locale: string
  createdAt: string
  updatedAt: string
  experience: number
  warmUps: number
  level: number
  levelUpXP: number
  constructedStats?: AccountStat
  discoveryStats?: AccountStat
  region?: string
  tagArtID?: string
  crystalID?: number
  settings?: AccountSettings
  invitedBy?: string
}

export interface AccountSettings {
  hidePlayerNames?: boolean
  suspended?: boolean
  requestMoreInvites?: boolean
  renameLockedUntil?: string
  starterDeckMigration?: boolean
  spectateCode?: string
  spectateCodeExpiresAt?: string
  twitchProfile?: string
}

export interface AccountStat {
  accountAddress: string
  gameMode: GameMode
  winCount: number
  lossCount: number
  tieCount: number
  forfeitCount: number
  abandonCount: number
  winRatio: number
  gamesPlayed: number
  score: number
  createdAt: string
  rank?: number
  rankProgress?: number
  playerRank: PlayerRank
  playerRankScore: number
  winStreak: number
  lossStreak: number
  season?: number
}

export interface SetInvitedByRequest {
  address: string
  invitedBy: string
}

export interface Item {
  id: number
  accountAddress: string
  contractAddress?: string
  itemType: ItemType
  tokenID: number
  balance: string
  lastUpdateID: number
  updatedAt?: string
  createdAt?: string
}

export interface ItemSummary {
  id: number
  accountAddress: string
  itemType: ItemType
  totalBalance: string
  updatedAt?: string
  createdAt?: string
}

export interface ItemSupply {
  itemID: number
  itemType: ItemType
  totalBalance: string
}

export interface GetFeedRequest {
  accountAddress: string
  types?: Array<FeedEventType>
}

export interface FeedEvent {
  id: number
  accountAddress: string
  type: FeedEventType
  createdAt: string
  match: Match
  level?: number
  playerRank?: PlayerRank
  tokenIds?: Array<number>
  cards: Array<Card>
  heroes: Array<Hero>
  gameMode?: GameMode
  leaderboardRank?: number
}

export interface CardImageURL {
  small: string
  medium: string
  large: string
}

export interface Card {
  id: number
  name: string
  description: string
  asset: string
  class: CardClass
  element: CardElement
  type: CardType
  manaCost: number
  power: number
  health: number
  attachedSpellID?: number
  keywords: Array<string>
  status: CardStatus
  
  imageURL: CardImageURL
  itemType: ItemType
}

export interface Sticker {
  id: number
  name: string
  requiredPoints: number
  asset: string
  tokenId: number
  season: number
}

export interface StickerOwnershipResponse {
  stickerBalances: {[key: number]: BalanceTuple}
}

export interface LevelsPerSeason {
  address: string
  inviter_address: string
  season: number
  levels: number
  pointsCarried: number
  pointsSpent: number
}

export interface FriendPoints {
  account?: Account
  season: number
  levels: number
  points: number
  pointsSpent: number
}

export interface CardSearchCriteria {
  ids?: Array<number>
  cardClass?: Array<CardClass>
  cardType?: CardType
  cardElement?: Array<CardElement>
  searchText?: string
  cardManaCost?: Array<string>
  itemType?: ItemType
  ownedCards?: boolean
  accountAddress?: string
  includeTokens?: boolean
}

export interface GetCardsRequest {
  ids: Array<number>
  includeUserBalances: boolean
  accountAddress?: string
}

export interface SearchCardsRequest {
  criteria: CardSearchCriteria
  includeUserBalances: boolean
  contractQuery: boolean
}

export interface CardWithBalance {
  card: Card
  balance: string
  balanceByType: {[key: string]: BalanceTuple}
  createdAt: string
}

export interface BalanceTuple {
  balance: string
}

export interface CardOwnershipResponse {
  cardBalances: {[key: number]: {[key: string]: BalanceTuple}}
  lockedCards: number
  lockedCardsByClass: {[key: string]: number}
  lockedCardsByFrame: {[key: string]: number}
  lockedCardsByClassAndFrame: {[key: string]: {[key: string]: number}}
  unlockedCards: number
  unlockedCardsByClass: {[key: string]: number}
  unlockedCardsByFrame: {[key: string]: number}
  unlockedCardsByClassAndFrame: {[key: string]: {[key: string]: number}}
  pendingCards: number
  pendingCardsByClass: {[key: string]: number}
  pendingCardsByFrame: {[key: string]: number}
  pendingCardsByClassAndFrame: {[key: string]: {[key: string]: number}}
}

export interface PendingCardsResponse {
  cards: Array<Card>
  tokenIDs: Array<number>
  mintAt: string
}

export interface Deck {
  uuid: string
  accountAddress: string
  name: string
  class: DeckClass
  deckString: string
  cardIds: Array<number>
  art: string
  createdAt: string
  updatedAt: string
  isFavorite: boolean
  favoritedAt: string
  deckType: DeckType
  isNew: boolean
}

export interface CheckDeckResponse {
  containsInvalid: boolean
  accountOwnsAllCards: boolean
  unlockedClass: boolean
}

export interface CreateDeckRequest {
  name: string
  class?: DeckClass
  cardIds: Array<number>
  art?: string
}

export interface UpdateDeckRequestDeck {
  deckString: string
  name: string
  class: DeckClass
  art?: string
}

export interface UpdateDeckRequest {
  uuid?: string
  deckString?: string
  deck: UpdateDeckRequestDeck
}

export interface DeckRequest {
  uuid?: string
  deckString?: string
}

export interface CheckDeckRequest {
  accountAddress?: string
  uuid?: string
  deckString?: string
  contractQuery: boolean
}

export interface SearchDecksRequest {
  deckString?: string
  name?: string
  class?: DeckClass
}

export interface DeckRank {
  deckString: string
  class: DeckClass
  cardIds: Array<number>
  winCount: number
  lossCount: number
  forfeitCount: number
  abandonCount: number
  tieCount: number
  winRatio: number
  gamesPlayed: number
  score: number
  highestPlayerAddress: string
}

export interface SearchDeckRanksRequest {
  deckString?: string
  classes?: Array<DeckClass>
  withCards?: Array<number>
}

export interface ListDeckRanksRequest {
  class?: DeckClass
}

export interface DeckRankAccount {
  deckRank: DeckRank
  highestPlayer: Account
}

export interface Match {
  id: number
  status: MatchStatus
  mode: GameMode
  player1: MatchPlayer
  player2: MatchPlayer
  initPlayer1DeckNumCards: number
  initPlayer2DeckNumCards: number
  player1DeckClass?: DeckClass
  player2DeckClass?: DeckClass
  winningPlayer?: number
  turnNonce: number
  player1Moves: number
  player2Moves: number
  metrics: {[key: string]: any}
  startedAt?: string
  endedAt?: string
  updatedAt?: string
  createdAt?: string
  replayID: string
}

export interface WeeklyGolds {
  startAt: string
  endAt: string
  tokenId: number
  totalSupply: number
}

export interface MatchPlayer {
  address: string
  name: string
  region?: string
  tagArtID?: string
  crystalID?: number
  deckString: string
  initDeckString: string
  deckClass: DeckClass
  playerSessionId?: string
  isBot: boolean
}

export interface RankData {
  rank: PlayerRank
  rankPoints: number
  requiredRankPoints: number
  eloScore: number
  rankPosition: number
  eloAbove: number
  eloBelow: number
}

export interface RewardRank {
  beforeMatch: RankData
  afterMatch: RankData
}

export interface RewardExp {
  amount: number
  description: string
  currentLevel: number
  requiredExp: number
}

export interface RewardCard {
  amount: number
  description: string
  card: Card
  item?: Item
}

export interface RewardHero {
  hero: Hero
  deckClass: DeckClass
}

export interface RewardHeroSkin {
  hero: Hero
  deckClass: DeckClass
  tokenId: number
}

export interface RewardDeck {
  deckClass: DeckClass
  tokenIds: Array<number>
}

export interface Reward {
  accountAddress: string
  type: RewardType
  rank?: RewardRank
  exp?: RewardExp
  card?: RewardCard
  hero?: RewardHero
  heroSkin?: RewardHeroSkin
  deck?: RewardDeck
}

export interface ListLeaderboardRequest {
  gameMode?: GameMode
  region?: string
  playerRank?: PlayerRank
  playerNamePrefix?: string
  season?: number
}

export interface AccountLeaderboardRequest {
  gameMode: GameMode
  accountAddress?: string
  season?: number
}

export interface LeaderboardEntry {
  account: Account
  accountStat: AccountStat
  rank: number
  rankedSilverReward: number
  rankedTicketReward: number
  
}

export interface ListMatchesRequest {
  accountAddress?: string
}

export interface Notification {
  id: number
  channel: string
  type: number
  content: string
  read: boolean
  deliveredAt: string
  createdAt: string
}

export interface ListNotificationsRequest {
  from: string
  until: string
  limit: number
}

export interface GameClientFeedback {
  sentiment: string
  timestamp: string
  dump: {[key: string]: any}
  screenshotImageURI: string
}

export interface Conquest {
  id: number
  status: ConquestStatus
  accountAddress: string
  nonce: number
  mode: GameMode
  hero: Hero
  deckClass?: DeckClass
  matchProgress: {[key: number]: ConquestMatchResult}
  createdAt?: string
  endedAt?: string
}

export interface ConquestStats {
  discoveryTicketsUsed: number
  constructedTicketsUsed: number
  discoveryMatchesPlayed: number
  constructedMatchesPlayed: number
  discoveryWinRate: number
  constructedWinRate: number
  discoverySilverCardsWon: number
  constructedSilverCardsWon: number
  discoveryGoldCardsWon: number
  constructedGoldCardsWon: number
  firstConquestMatchPlayed: string
}

export interface ConquestPoints {
  address: string
  eventID: number
  currentPoints: number
  totalPoints: number
}

export interface Page {
  pageSize?: number
  before?: string
  hasBefore?: boolean
  after?: string
  hasAfter?: boolean
  sort?: Array<SortBy>
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface TwitchFeaturedStreamer {
  username: string
}

export interface Banner {
  order: number
  type: BannerType
  color?: string
  msg: string
  dismissable: boolean
  id: number
  link?: string
  startAt?: string
  endAt?: string
}

export interface BannersRequest {
  order: number
  bannerType: BannerType
  msg: string
  dismissable: boolean
  color?: string
  link?: string
  startAt?: string
  endAt?: string
}

export interface TwitchInfoResponse {
  streamers_online: number
  vods_available: number
  streams: Array<TwitchStream>
}

export interface TwitchStream {
  id: string
  user_id: string
  user_login: string
  user_name: string
  game_id: string
  game_name: string
  type: string
  title: string
  viewer_count: number
  started_at: string
  language: string
  thumbnail_url: string
  tag_ids: Array<string>
  is_mature: boolean
}

export interface DiscordInfoResponse {
  users_online: number
  instant_invite_url: string
}

export interface SkyWeaverAPI {
  getSession(headers?: object): Promise<GetSessionReturn>
  getAccount(args: GetAccountArgs, headers?: object): Promise<GetAccountReturn>
  getAccountByUsername(args: GetAccountByUsernameArgs, headers?: object): Promise<GetAccountByUsernameReturn>
  getAccountStats(args: GetAccountStatsArgs, headers?: object): Promise<GetAccountStatsReturn>
  accountExists(args: AccountExistsArgs, headers?: object): Promise<AccountExistsReturn>
  accountExistsByName(args: AccountExistsByNameArgs, headers?: object): Promise<AccountExistsByNameReturn>
  updateAccount(args: UpdateAccountArgs, headers?: object): Promise<UpdateAccountReturn>
  listNotifications(args: ListNotificationsArgs, headers?: object): Promise<ListNotificationsReturn>
  getPrivateSpectateCode(args: GetPrivateSpectateCodeArgs, headers?: object): Promise<GetPrivateSpectateCodeReturn>
  getFriendPoints(args: GetFriendPointsArgs, headers?: object): Promise<GetFriendPointsReturn>
  getFriendPointsBySeason(args: GetFriendPointsBySeasonArgs, headers?: object): Promise<GetFriendPointsBySeasonReturn>
  getPointsGifted(args: GetPointsGiftedArgs, headers?: object): Promise<GetPointsGiftedReturn>
  getStickers(headers?: object): Promise<GetStickersReturn>
  getStickersBySeason(args: GetStickersBySeasonArgs, headers?: object): Promise<GetStickersBySeasonReturn>
  getStickerOwnership(args: GetStickerOwnershipArgs, headers?: object): Promise<GetStickerOwnershipReturn>
  getFeed(args: GetFeedArgs, headers?: object): Promise<GetFeedReturn>
  getItemSummary(args: GetItemSummaryArgs, headers?: object): Promise<GetItemSummaryReturn>
  getItemSupply(args: GetItemSupplyArgs, headers?: object): Promise<GetItemSupplyReturn>
  getBatchItemSupply(args: GetBatchItemSupplyArgs, headers?: object): Promise<GetBatchItemSupplyReturn>
  getItemSuppliesByType(args: GetItemSuppliesByTypeArgs, headers?: object): Promise<GetItemSuppliesByTypeReturn>
  getCardLibrary(args: GetCardLibraryArgs, headers?: object): Promise<GetCardLibraryReturn>
  getCardsByID(args: GetCardsByIDArgs, headers?: object): Promise<GetCardsByIDReturn>
  getCardsByDeckString(args: GetCardsByDeckStringArgs, headers?: object): Promise<GetCardsByDeckStringReturn>
  searchCards(args: SearchCardsArgs, headers?: object): Promise<SearchCardsReturn>
  getCardOwnership(args: GetCardOwnershipArgs, headers?: object): Promise<GetCardOwnershipReturn>
  getPendingCards(headers?: object): Promise<GetPendingCardsReturn>
  listDecks(args: ListDecksArgs, headers?: object): Promise<ListDecksReturn>
  searchDecks(args: SearchDecksArgs, headers?: object): Promise<SearchDecksReturn>
  createDeck(args: CreateDeckArgs, headers?: object): Promise<CreateDeckReturn>
  updateDeck(args: UpdateDeckArgs, headers?: object): Promise<UpdateDeckReturn>
  favoriteDeck(args: FavoriteDeckArgs, headers?: object): Promise<FavoriteDeckReturn>
  unfavoriteDeck(args: UnfavoriteDeckArgs, headers?: object): Promise<UnfavoriteDeckReturn>
  toggleDeckFavorite(args: ToggleDeckFavoriteArgs, headers?: object): Promise<ToggleDeckFavoriteReturn>
  getDeck(args: GetDeckArgs, headers?: object): Promise<GetDeckReturn>
  checkDeck(args: CheckDeckArgs, headers?: object): Promise<CheckDeckReturn>
  deleteDeck(args: DeleteDeckArgs, headers?: object): Promise<DeleteDeckReturn>
  searchDeckRanks(args: SearchDeckRanksArgs, headers?: object): Promise<SearchDeckRanksReturn>
  listDeckRanks(args: ListDeckRanksArgs, headers?: object): Promise<ListDeckRanksReturn>
  markDeckNotNew(args: MarkDeckNotNewArgs, headers?: object): Promise<MarkDeckNotNewReturn>
  listLeaderboard(args: ListLeaderboardArgs, headers?: object): Promise<ListLeaderboardReturn>
  listMatches(args: ListMatchesArgs, headers?: object): Promise<ListMatchesReturn>
  getMatch(args: GetMatchArgs, headers?: object): Promise<GetMatchReturn>
  getCurrentSeason(headers?: object): Promise<GetCurrentSeasonReturn>
  getNextRewardsTime(headers?: object): Promise<GetNextRewardsTimeReturn>
  getNextSeasonTime(headers?: object): Promise<GetNextSeasonTimeReturn>
  getCurrentSeasonStartTime(headers?: object): Promise<GetCurrentSeasonStartTimeReturn>
  accountLeaderboard(args: AccountLeaderboardArgs, headers?: object): Promise<AccountLeaderboardReturn>
  getMatchArchiveRecordsURI(args: GetMatchArchiveRecordsURIArgs, headers?: object): Promise<GetMatchArchiveRecordsURIReturn>
  getMatchLiveRecordsURI(args: GetMatchLiveRecordsURIArgs, headers?: object): Promise<GetMatchLiveRecordsURIReturn>
  conquestStats(headers?: object): Promise<ConquestStatsReturn>
  conquestRewards(headers?: object): Promise<ConquestRewardsReturn>
  conquestPoints(headers?: object): Promise<ConquestPointsReturn>
  heroUnlockLevels(headers?: object): Promise<HeroUnlockLevelsReturn>
  deckClassUnlockLevels(headers?: object): Promise<DeckClassUnlockLevelsReturn>
  availableXPBonuses(headers?: object): Promise<AvailableXPBonusesReturn>
  getDiscordInfo(headers?: object): Promise<GetDiscordInfoReturn>
  getTwitchInfo(headers?: object): Promise<GetTwitchInfoReturn>
  getFeaturedStreamers(headers?: object): Promise<GetFeaturedStreamersReturn>
  getBanners(headers?: object): Promise<GetBannersReturn>
  ping(headers?: object): Promise<PingReturn>
  version(headers?: object): Promise<VersionReturn>
}

export interface GetAuthTokenArgs {
  ethAuthProofString: string
}

export interface GetAuthTokenReturn {
  status: boolean
  jwtToken: string
  address: string
  account?: Account  
}
export interface GetSessionArgs {
}

export interface GetSessionReturn {
  address: string
  account?: Account  
}

export interface MigrateAccountReturn {
  ok: boolean  
}
export interface RegisterAccountArgs {
  account: Account
  captcha: string
}

export interface RegisterAccountReturn {
  status: boolean
  account: Account  
}
export interface GetAccountArgs {
  address: string
}

export interface GetAccountReturn {
  account: Account  
}
export interface GetAccountByUsernameArgs {
  username: string
}

export interface GetAccountByUsernameReturn {
  account: Account  
}
export interface GetAccountStatsArgs {
  address: string
  seasons?: Array<number>
}

export interface GetAccountStatsReturn {
  constructedStats: Array<AccountStat>
  discoveryStats: Array<AccountStat>  
}
export interface AccountExistsArgs {
  address: string
}

export interface AccountExistsReturn {
  exists: boolean
  pending_migration: boolean  
}
export interface AccountExistsByNameArgs {
  name: string
}

export interface AccountExistsByNameReturn {
  exists: boolean
  pending_migration: boolean  
}
export interface UpdateAccountArgs {
  account: Account
}

export interface UpdateAccountReturn {
  account: Account  
}

export interface RequestAccountDeletionReturn {
  status: boolean  
}
export interface ListNotificationsArgs {
  req: ListNotificationsRequest
}

export interface ListNotificationsReturn {
  res: Array<Notification>  
}
export interface RequestMoreInvitesArgs {
}

export interface RequestMoreInvitesReturn {
  status: boolean  
}
export interface SetInvitedByArgs {
  req: SetInvitedByRequest
}

export interface SetInvitedByReturn {
  ok: boolean  
}
export interface GetPrivateSpectateCodeArgs {
  reset?: boolean
}

export interface GetPrivateSpectateCodeReturn {
  code: string  
}
export interface GetFriendPointsArgs {
  address: string
}

export interface GetFriendPointsReturn {
  total: number
  friends: Array<FriendPoints>  
}
export interface GetFriendPointsBySeasonArgs {
  address: string
  season: number
}

export interface GetFriendPointsBySeasonReturn {
  total: number
  friends: Array<FriendPoints>  
}
export interface GetPointsGiftedArgs {
  address: string
}

export interface GetPointsGiftedReturn {
  total: number
  inviter: Account  
}
export interface GetStickersArgs {
}

export interface GetStickersReturn {
  stickers: Array<Sticker>  
}
export interface GetStickersBySeasonArgs {
  season: number
}

export interface GetStickersBySeasonReturn {
  stickers: Array<Sticker>  
}
export interface GetStickerOwnershipArgs {
  accountAddress?: string
}

export interface GetStickerOwnershipReturn {
  res: StickerOwnershipResponse  
}

export interface GetFeedArgs {
  page?: Page
  req: GetFeedRequest
}

export interface GetFeedReturn {
  page?: Page
  res: Array<FeedEvent>  
}
export interface GetItemSummaryArgs {
  accountAddress: string
  contractQuery?: boolean
}

export interface GetItemSummaryReturn {
  summary: {[key: string]: ItemSummary}  
}
export interface GetItemSupplyArgs {
  tokenID: number
}

export interface GetItemSupplyReturn {
  summary: {[key: string]: Item}  
}
export interface GetBatchItemSupplyArgs {
  tokenIDs: Array<number>
}

export interface GetBatchItemSupplyReturn {
  summary: {[key: number]: {[key: string]: Item}}  
}
export interface GetItemSuppliesByTypeArgs {
  itemTypes: Array<ItemType>
}

export interface GetItemSuppliesByTypeReturn {
  summary: {[key: number]: Array<ItemSupply>}  
}
export interface GetCardLibraryArgs {
  page?: Page
}

export interface GetCardLibraryReturn {
  cards: Array<Card>  
}
export interface GetCardsByIDArgs {
  cardIDs: Array<number>
}

export interface GetCardsByIDReturn {
  cards: Array<Card>  
}
export interface GetCardsByDeckStringArgs {
  deckString: string
}

export interface GetCardsByDeckStringReturn {
  cards: Array<Card>  
}
export interface SearchCardsArgs {
  page?: Page
  req: SearchCardsRequest
}

export interface SearchCardsReturn {
  page?: Page
  res: Array<CardWithBalance>  
}
export interface GetCardOwnershipArgs {
  accountAddress?: string
  contractQuery?: boolean
}

export interface GetCardOwnershipReturn {
  res: CardOwnershipResponse  
}
export interface GetPendingCardsArgs {
}

export interface GetPendingCardsReturn {
  res: Array<PendingCardsResponse>  
}
export interface ListDecksArgs {
  page?: Page
}

export interface ListDecksReturn {
  page?: Page
  res: Array<Deck>  
}
export interface SearchDecksArgs {
  page?: Page
  req: SearchDecksRequest
}

export interface SearchDecksReturn {
  page?: Page
  res: Array<Deck>  
}
export interface CreateDeckArgs {
  req: CreateDeckRequest
}

export interface CreateDeckReturn {
  res: Deck  
}
export interface UpdateDeckArgs {
  req: UpdateDeckRequest
}

export interface UpdateDeckReturn {
  res: Deck  
}
export interface FavoriteDeckArgs {
  uuid: string
}

export interface FavoriteDeckReturn {
  ok: boolean  
}
export interface UnfavoriteDeckArgs {
  uuid: string
}

export interface UnfavoriteDeckReturn {
  ok: boolean  
}
export interface ToggleDeckFavoriteArgs {
  uuid: string
}

export interface ToggleDeckFavoriteReturn {
  isFavorite: boolean  
}
export interface GetDeckArgs {
  req: DeckRequest
}

export interface GetDeckReturn {
  res: Deck  
}
export interface CheckDeckArgs {
  req: CheckDeckRequest
}

export interface CheckDeckReturn {
  res: CheckDeckResponse  
}
export interface DeleteDeckArgs {
  req: DeckRequest
}

export interface DeleteDeckReturn {
  ok: boolean  
}
export interface SearchDeckRanksArgs {
  page?: Page
  req: SearchDeckRanksRequest
}

export interface SearchDeckRanksReturn {
  page?: Page
  res: Array<DeckRank>  
}
export interface ListDeckRanksArgs {
  page?: Page
  req: ListDeckRanksRequest
}

export interface ListDeckRanksReturn {
  page?: Page
  res: Array<DeckRankAccount>  
}
export interface MarkDeckNotNewArgs {
  uuid: string
}

export interface MarkDeckNotNewReturn {
  ok: boolean  
}
export interface ListLeaderboardArgs {
  page?: Page
  req: ListLeaderboardRequest
}

export interface ListLeaderboardReturn {
  page?: Page
  res: Array<LeaderboardEntry>  
}
export interface ListMatchesArgs {
  page?: Page
  req: ListMatchesRequest
}

export interface ListMatchesReturn {
  page?: Page
  res: Array<Match>  
}
export interface GetMatchArgs {
  matchID: number
}

export interface GetMatchReturn {
  match: Match  
}
export interface GetCurrentSeasonArgs {
}

export interface GetCurrentSeasonReturn {
  res: number  
}
export interface GetNextRewardsTimeArgs {
}

export interface GetNextRewardsTimeReturn {
  res: string  
}
export interface GetNextSeasonTimeArgs {
}

export interface GetNextSeasonTimeReturn {
  res: string  
}
export interface GetCurrentSeasonStartTimeArgs {
}

export interface GetCurrentSeasonStartTimeReturn {
  res: string  
}
export interface AccountLeaderboardArgs {
  page?: Page
  req: AccountLeaderboardRequest
}

export interface AccountLeaderboardReturn {
  page?: Page
  res: Array<LeaderboardEntry>  
}
export interface GetMatchArchiveRecordsURIArgs {
  matchID: number
  replayID: string
}

export interface GetMatchArchiveRecordsURIReturn {
  ok: boolean
  match?: Match
  archiveIndexURI: string
  recordURIs: Array<string>  
}
export interface GetMatchLiveRecordsURIArgs {
  matchID: number
}

export interface GetMatchLiveRecordsURIReturn {
  ok: boolean
  match?: Match
  liveIndexURI: string  
}

export interface InternalMatchEndReturn {
  rewards: Array<Reward>  
}
export interface InternalAppendMatchArchiveRecordsArgs {
  matchID: number
  index: number
  jsonStringData: string
}

export interface InternalAppendMatchArchiveRecordsReturn {
  status: boolean
  uri: string  
}
export interface InternalAppendMatchLiveRecordsArgs {
  matchID: number
  index: number
  jsonStringData: string
}

export interface InternalAppendMatchLiveRecordsReturn {
  status: boolean
  uri: string  
}
export interface InternalConquestStatusArgs {
  address: string
}

export interface InternalConquestStatusReturn {
  conquest: Conquest  
}
export interface InternalGetAccountArgs {
  address: string
}

export interface InternalGetAccountReturn {
  account: Account  
}
export interface InternalGetPrivateSpectateCodeArgs {
  address: string
}

export interface InternalGetPrivateSpectateCodeReturn {
  code: string  
}
export interface EnterConquestArgs {
  hero: Hero
  mode: GameMode
}

export interface EnterConquestReturn {
  status: boolean  
}
export interface ConquestStatusArgs {
}

export interface ConquestStatusReturn {
  conquest: Conquest  
}
export interface ConquestStatsArgs {
}

export interface ConquestStatsReturn {
  stats: ConquestStats  
}
export interface ConquestRewardsArgs {
}

export interface ConquestRewardsReturn {
  weeklyGolds: Array<WeeklyGolds>  
}

export interface ConquestPointsArgs {
}

export interface ConquestPointsReturn {
  points: number
  nedeed: number  
}
export interface IAPVerifyGoogleProductsArgs {
  packageName: string
  productId: string
  token: string
  address: string
}

export interface HeroUnlockLevelsArgs {
}

export interface HeroUnlockLevelsReturn {
  res: {[key: string]: number}  
}
export interface DeckClassUnlockLevelsArgs {
}

export interface DeckClassUnlockLevelsReturn {
  res: {[key: string]: number}  
}
export interface AvailableXPBonusesArgs {
}

export interface AvailableXPBonusesReturn {
  res: number  
}

export interface ReportAccountReturn {
  ok: boolean  
}

export interface GetDiscordInfoArgs {
}

export interface GetDiscordInfoReturn {
  data: DiscordInfoResponse  
}
export interface GetTwitchInfoArgs {
}

export interface GetTwitchInfoReturn {
  data: TwitchInfoResponse  
}
export interface GetFeaturedStreamersArgs {
}

export interface GetFeaturedStreamersReturn {
  streamers: Array<TwitchFeaturedStreamer>  
}

export interface GetBannersArgs {
}

export interface GetBannersReturn {
  banners: Array<Banner>  
}
export interface GMListBannersArgs {
}

export interface GMListBannersReturn {
  banners: Array<Banner>  
}

export interface PingArgs {
}

export interface PingReturn {
  status: boolean  
}
export interface VersionArgs {
}

export interface VersionReturn {
  version: Version  
}


  
//
// Client
//
export class SkyWeaverAPI implements SkyWeaverAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/SkyWeaverAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  getSession = (headers?: object): Promise<GetSessionReturn> => {
    return this.fetch(
      this.url('GetSession'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          address: <string>(_data.address), 
          account: <Account>(_data.account)
        }
      })
    })
  }
  
  getAccount = (args: GetAccountArgs, headers?: object): Promise<GetAccountReturn> => {
    return this.fetch(
      this.url('GetAccount'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          account: <Account>(_data.account)
        }
      })
    })
  }
  
  getAccountByUsername = (args: GetAccountByUsernameArgs, headers?: object): Promise<GetAccountByUsernameReturn> => {
    return this.fetch(
      this.url('GetAccountByUsername'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          account: <Account>(_data.account)
        }
      })
    })
  }
  
  getAccountStats = (args: GetAccountStatsArgs, headers?: object): Promise<GetAccountStatsReturn> => {
    return this.fetch(
      this.url('GetAccountStats'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          constructedStats: <Array<AccountStat>>(_data.constructedStats), 
          discoveryStats: <Array<AccountStat>>(_data.discoveryStats)
        }
      })
    })
  }
  
  accountExists = (args: AccountExistsArgs, headers?: object): Promise<AccountExistsReturn> => {
    return this.fetch(
      this.url('AccountExists'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          exists: <boolean>(_data.exists), 
          pending_migration: <boolean>(_data.pending_migration)
        }
      })
    })
  }
  
  accountExistsByName = (args: AccountExistsByNameArgs, headers?: object): Promise<AccountExistsByNameReturn> => {
    return this.fetch(
      this.url('AccountExistsByName'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          exists: <boolean>(_data.exists), 
          pending_migration: <boolean>(_data.pending_migration)
        }
      })
    })
  }
  
  updateAccount = (args: UpdateAccountArgs, headers?: object): Promise<UpdateAccountReturn> => {
    return this.fetch(
      this.url('UpdateAccount'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          account: <Account>(_data.account)
        }
      })
    })
  }
  
  listNotifications = (args: ListNotificationsArgs, headers?: object): Promise<ListNotificationsReturn> => {
    return this.fetch(
      this.url('ListNotifications'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <Array<Notification>>(_data.res)
        }
      })
    })
  }
  
  requestMoreInvites = (headers?: object): Promise<RequestMoreInvitesReturn> => {
    return this.fetch(
      this.url('RequestMoreInvites'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>(_data.status)
        }
      })
    })
  }
  
  setInvitedBy = (args: SetInvitedByArgs, headers?: object): Promise<SetInvitedByReturn> => {
    return this.fetch(
      this.url('SetInvitedBy'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok)
        }
      })
    })
  }
  
  getPrivateSpectateCode = (args: GetPrivateSpectateCodeArgs, headers?: object): Promise<GetPrivateSpectateCodeReturn> => {
    return this.fetch(
      this.url('GetPrivateSpectateCode'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          code: <string>(_data.code)
        }
      })
    })
  }
  
  getFriendPoints = (args: GetFriendPointsArgs, headers?: object): Promise<GetFriendPointsReturn> => {
    return this.fetch(
      this.url('GetFriendPoints'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          total: <number>(_data.total), 
          friends: <Array<FriendPoints>>(_data.friends)
        }
      })
    })
  }
  
  getFriendPointsBySeason = (args: GetFriendPointsBySeasonArgs, headers?: object): Promise<GetFriendPointsBySeasonReturn> => {
    return this.fetch(
      this.url('GetFriendPointsBySeason'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          total: <number>(_data.total), 
          friends: <Array<FriendPoints>>(_data.friends)
        }
      })
    })
  }
  
  getPointsGifted = (args: GetPointsGiftedArgs, headers?: object): Promise<GetPointsGiftedReturn> => {
    return this.fetch(
      this.url('GetPointsGifted'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          total: <number>(_data.total), 
          inviter: <Account>(_data.inviter)
        }
      })
    })
  }
  
  getStickers = (headers?: object): Promise<GetStickersReturn> => {
    return this.fetch(
      this.url('GetStickers'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          stickers: <Array<Sticker>>(_data.stickers)
        }
      })
    })
  }
  
  getStickersBySeason = (args: GetStickersBySeasonArgs, headers?: object): Promise<GetStickersBySeasonReturn> => {
    return this.fetch(
      this.url('GetStickersBySeason'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          stickers: <Array<Sticker>>(_data.stickers)
        }
      })
    })
  }
  
  getStickerOwnership = (args: GetStickerOwnershipArgs, headers?: object): Promise<GetStickerOwnershipReturn> => {
    return this.fetch(
      this.url('GetStickerOwnership'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <StickerOwnershipResponse>(_data.res)
        }
      })
    })
  }
  
  getFeed = (args: GetFeedArgs, headers?: object): Promise<GetFeedReturn> => {
    return this.fetch(
      this.url('GetFeed'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<FeedEvent>>(_data.res)
        }
      })
    })
  }
  
  getItemSummary = (args: GetItemSummaryArgs, headers?: object): Promise<GetItemSummaryReturn> => {
    return this.fetch(
      this.url('GetItemSummary'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          summary: <{[key: string]: ItemSummary}>(_data.summary)
        }
      })
    })
  }
  
  getItemSupply = (args: GetItemSupplyArgs, headers?: object): Promise<GetItemSupplyReturn> => {
    return this.fetch(
      this.url('GetItemSupply'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          summary: <{[key: string]: Item}>(_data.summary)
        }
      })
    })
  }
  
  getBatchItemSupply = (args: GetBatchItemSupplyArgs, headers?: object): Promise<GetBatchItemSupplyReturn> => {
    return this.fetch(
      this.url('GetBatchItemSupply'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          summary: <{[key: number]: {[key: string]: Item}}>(_data.summary)
        }
      })
    })
  }
  
  getItemSuppliesByType = (args: GetItemSuppliesByTypeArgs, headers?: object): Promise<GetItemSuppliesByTypeReturn> => {
    return this.fetch(
      this.url('GetItemSuppliesByType'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          summary: <{[key: number]: Array<ItemSupply>}>(_data.summary)
        }
      })
    })
  }
  
  getCardLibrary = (args: GetCardLibraryArgs, headers?: object): Promise<GetCardLibraryReturn> => {
    return this.fetch(
      this.url('GetCardLibrary'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          cards: <Array<Card>>(_data.cards)
        }
      })
    })
  }
  
  getCardsByID = (args: GetCardsByIDArgs, headers?: object): Promise<GetCardsByIDReturn> => {
    return this.fetch(
      this.url('GetCardsByID'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          cards: <Array<Card>>(_data.cards)
        }
      })
    })
  }
  
  getCardsByDeckString = (args: GetCardsByDeckStringArgs, headers?: object): Promise<GetCardsByDeckStringReturn> => {
    return this.fetch(
      this.url('GetCardsByDeckString'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          cards: <Array<Card>>(_data.cards)
        }
      })
    })
  }
  
  searchCards = (args: SearchCardsArgs, headers?: object): Promise<SearchCardsReturn> => {
    return this.fetch(
      this.url('SearchCards'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<CardWithBalance>>(_data.res)
        }
      })
    })
  }
  
  getCardOwnership = (args: GetCardOwnershipArgs, headers?: object): Promise<GetCardOwnershipReturn> => {
    return this.fetch(
      this.url('GetCardOwnership'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <CardOwnershipResponse>(_data.res)
        }
      })
    })
  }
  
  getPendingCards = (headers?: object): Promise<GetPendingCardsReturn> => {
    return this.fetch(
      this.url('GetPendingCards'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <Array<PendingCardsResponse>>(_data.res)
        }
      })
    })
  }
  
  listDecks = (args: ListDecksArgs, headers?: object): Promise<ListDecksReturn> => {
    return this.fetch(
      this.url('ListDecks'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<Deck>>(_data.res)
        }
      })
    })
  }
  
  searchDecks = (args: SearchDecksArgs, headers?: object): Promise<SearchDecksReturn> => {
    return this.fetch(
      this.url('SearchDecks'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<Deck>>(_data.res)
        }
      })
    })
  }
  
  createDeck = (args: CreateDeckArgs, headers?: object): Promise<CreateDeckReturn> => {
    return this.fetch(
      this.url('CreateDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <Deck>(_data.res)
        }
      })
    })
  }
  
  updateDeck = (args: UpdateDeckArgs, headers?: object): Promise<UpdateDeckReturn> => {
    return this.fetch(
      this.url('UpdateDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <Deck>(_data.res)
        }
      })
    })
  }
  
  favoriteDeck = (args: FavoriteDeckArgs, headers?: object): Promise<FavoriteDeckReturn> => {
    return this.fetch(
      this.url('FavoriteDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok)
        }
      })
    })
  }
  
  unfavoriteDeck = (args: UnfavoriteDeckArgs, headers?: object): Promise<UnfavoriteDeckReturn> => {
    return this.fetch(
      this.url('UnfavoriteDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok)
        }
      })
    })
  }
  
  toggleDeckFavorite = (args: ToggleDeckFavoriteArgs, headers?: object): Promise<ToggleDeckFavoriteReturn> => {
    return this.fetch(
      this.url('ToggleDeckFavorite'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          isFavorite: <boolean>(_data.isFavorite)
        }
      })
    })
  }
  
  getDeck = (args: GetDeckArgs, headers?: object): Promise<GetDeckReturn> => {
    return this.fetch(
      this.url('GetDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <Deck>(_data.res)
        }
      })
    })
  }
  
  checkDeck = (args: CheckDeckArgs, headers?: object): Promise<CheckDeckReturn> => {
    return this.fetch(
      this.url('CheckDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <CheckDeckResponse>(_data.res)
        }
      })
    })
  }
  
  deleteDeck = (args: DeleteDeckArgs, headers?: object): Promise<DeleteDeckReturn> => {
    return this.fetch(
      this.url('DeleteDeck'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok)
        }
      })
    })
  }
  
  searchDeckRanks = (args: SearchDeckRanksArgs, headers?: object): Promise<SearchDeckRanksReturn> => {
    return this.fetch(
      this.url('SearchDeckRanks'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<DeckRank>>(_data.res)
        }
      })
    })
  }
  
  listDeckRanks = (args: ListDeckRanksArgs, headers?: object): Promise<ListDeckRanksReturn> => {
    return this.fetch(
      this.url('ListDeckRanks'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<DeckRankAccount>>(_data.res)
        }
      })
    })
  }
  
  markDeckNotNew = (args: MarkDeckNotNewArgs, headers?: object): Promise<MarkDeckNotNewReturn> => {
    return this.fetch(
      this.url('MarkDeckNotNew'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok)
        }
      })
    })
  }
  
  listLeaderboard = (args: ListLeaderboardArgs, headers?: object): Promise<ListLeaderboardReturn> => {
    return this.fetch(
      this.url('ListLeaderboard'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<LeaderboardEntry>>(_data.res)
        }
      })
    })
  }
  
  listMatches = (args: ListMatchesArgs, headers?: object): Promise<ListMatchesReturn> => {
    return this.fetch(
      this.url('ListMatches'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<Match>>(_data.res)
        }
      })
    })
  }
  
  getMatch = (args: GetMatchArgs, headers?: object): Promise<GetMatchReturn> => {
    return this.fetch(
      this.url('GetMatch'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          match: <Match>(_data.match)
        }
      })
    })
  }
  
  getCurrentSeason = (headers?: object): Promise<GetCurrentSeasonReturn> => {
    return this.fetch(
      this.url('GetCurrentSeason'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <number>(_data.res)
        }
      })
    })
  }
  
  getNextRewardsTime = (headers?: object): Promise<GetNextRewardsTimeReturn> => {
    return this.fetch(
      this.url('GetNextRewardsTime'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <string>(_data.res)
        }
      })
    })
  }
  
  getNextSeasonTime = (headers?: object): Promise<GetNextSeasonTimeReturn> => {
    return this.fetch(
      this.url('GetNextSeasonTime'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <string>(_data.res)
        }
      })
    })
  }
  
  getCurrentSeasonStartTime = (headers?: object): Promise<GetCurrentSeasonStartTimeReturn> => {
    return this.fetch(
      this.url('GetCurrentSeasonStartTime'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <string>(_data.res)
        }
      })
    })
  }
  
  accountLeaderboard = (args: AccountLeaderboardArgs, headers?: object): Promise<AccountLeaderboardReturn> => {
    return this.fetch(
      this.url('AccountLeaderboard'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>(_data.page), 
          res: <Array<LeaderboardEntry>>(_data.res)
        }
      })
    })
  }
  
  getMatchArchiveRecordsURI = (args: GetMatchArchiveRecordsURIArgs, headers?: object): Promise<GetMatchArchiveRecordsURIReturn> => {
    return this.fetch(
      this.url('GetMatchArchiveRecordsURI'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok), 
          match: <Match>(_data.match), 
          archiveIndexURI: <string>(_data.archiveIndexURI), 
          recordURIs: <Array<string>>(_data.recordURIs)
        }
      })
    })
  }
  
  getMatchLiveRecordsURI = (args: GetMatchLiveRecordsURIArgs, headers?: object): Promise<GetMatchLiveRecordsURIReturn> => {
    return this.fetch(
      this.url('GetMatchLiveRecordsURI'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>(_data.ok), 
          match: <Match>(_data.match), 
          liveIndexURI: <string>(_data.liveIndexURI)
        }
      })
    })
  }
  
  conquestStatus = (headers?: object): Promise<ConquestStatusReturn> => {
    return this.fetch(
      this.url('ConquestStatus'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          conquest: <Conquest>(_data.conquest)
        }
      })
    })
  }
  
  conquestStats = (headers?: object): Promise<ConquestStatsReturn> => {
    return this.fetch(
      this.url('ConquestStats'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          stats: <ConquestStats>(_data.stats)
        }
      })
    })
  }
  
  conquestRewards = (headers?: object): Promise<ConquestRewardsReturn> => {
    return this.fetch(
      this.url('ConquestRewards'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          weeklyGolds: <Array<WeeklyGolds>>(_data.weeklyGolds)
        }
      })
    })
  }
  
  conquestPoints = (headers?: object): Promise<ConquestPointsReturn> => {
    return this.fetch(
      this.url('ConquestPoints'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          points: <number>(_data.points), 
          nedeed: <number>(_data.nedeed)
        }
      })
    })
  }
  
  heroUnlockLevels = (headers?: object): Promise<HeroUnlockLevelsReturn> => {
    return this.fetch(
      this.url('HeroUnlockLevels'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <{[key: string]: number}>(_data.res)
        }
      })
    })
  }
  
  deckClassUnlockLevels = (headers?: object): Promise<DeckClassUnlockLevelsReturn> => {
    return this.fetch(
      this.url('DeckClassUnlockLevels'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <{[key: string]: number}>(_data.res)
        }
      })
    })
  }
  
  availableXPBonuses = (headers?: object): Promise<AvailableXPBonusesReturn> => {
    return this.fetch(
      this.url('AvailableXPBonuses'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          res: <number>(_data.res)
        }
      })
    })
  }
  
  getDiscordInfo = (headers?: object): Promise<GetDiscordInfoReturn> => {
    return this.fetch(
      this.url('GetDiscordInfo'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          data: <DiscordInfoResponse>(_data.data)
        }
      })
    })
  }
  
  getTwitchInfo = (headers?: object): Promise<GetTwitchInfoReturn> => {
    return this.fetch(
      this.url('GetTwitchInfo'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          data: <TwitchInfoResponse>(_data.data)
        }
      })
    })
  }
  
  getFeaturedStreamers = (headers?: object): Promise<GetFeaturedStreamersReturn> => {
    return this.fetch(
      this.url('GetFeaturedStreamers'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          streamers: <Array<TwitchFeaturedStreamer>>(_data.streamers)
        }
      })
    })
  }
  
  getBanners = (headers?: object): Promise<GetBannersReturn> => {
    return this.fetch(
      this.url('GetBanners'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          banners: <Array<Banner>>(_data.banners)
        }
      })
    })
  }
  
  gMListBanners = (headers?: object): Promise<GMListBannersReturn> => {
    return this.fetch(
      this.url('GMListBanners'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          banners: <Array<Banner>>(_data.banners)
        }
      })
    })
  }
  
  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(
      this.url('Ping'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>(_data.status)
        }
      })
    })
  }
  
  version = (headers?: object): Promise<VersionReturn> => {
    return this.fetch(
      this.url('Version'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          version: <Version>(_data.version)
        }
      })
    })
  }
  
}

  
export interface WebRPCError extends Error {
  code: string
  msg: string
	status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
